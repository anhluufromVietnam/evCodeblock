import * as Blockly from 'blockly';


export const jsonGenerator = new Blockly.Generator('JSON');


const Order = {
  ATOMIC: 0,
};

jsonGenerator.forBlock['logic_null'] = function (block) {
  return ['NULL', Order.ATOMIC];
};

jsonGenerator.forBlock['text'] = function (block) {
  const textValue = block.getFieldValue('TEXT');
  const code = `"${textValue}"`;
  return [code, Order.ATOMIC];
};


// Generator for the 'print' block
jsonGenerator.forBlock['print'] = function (block, generator) {
  // Get the MEMBER_VALUE, which is generated by any connected block (e.g., a 'text' block)

  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);

  // Generate code in the form of print("value")
  const code = `alert(${value});\n`;  // Adding semicolon and newline for separation
  return code;
};

// Generator for the 'print' block
jsonGenerator.forBlock['move'] = function (block, generator) {
  // Get the MEMBER_VALUE, which is generated by any connected block (e.g., a 'text' block)

  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);

  // Generate code in the form of print("value")
  const code = `sendData(${value});\n`;  // Adding semicolon and newline for separation
  return code;
};

// Generator for the 'print' block
jsonGenerator.forBlock['up'] = function (block, generator) {
  // Get the MEMBER_VALUE, which is generated by any connected block (e.g., a 'text' block)

  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);

  // Generate code in the form of print("value")
  const code = `await delay(${value});\n`;  // Adding semicolon and newline for separation
  return code;
};


jsonGenerator.forBlock['math_number'] = function (block) {
  const code = String(block.getFieldValue('NUM'));
  return [code, Order.ATOMIC];
};

jsonGenerator.forBlock['logic_boolean'] = function (block) {
  const code = (block.getFieldValue('BOOL') === 'TRUE') ? 'true' : 'false';
  return [code, Order.ATOMIC];
};

jsonGenerator.forBlock['member'] = function (block, generator) {
  const name = block.getFieldValue('MEMBER_NAME');
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const code = `"${name}": ${value}`;
  return code;
};

jsonGenerator.forBlock['lists_create_with'] = function (block, generator) {
  const values = [];
  for (let i = 0; i < block.itemCount_; i++) {
    const valueCode = generator.valueToCode(block, 'ADD' + i,
      Order.ATOMIC);
    if (valueCode) {
      values.push(valueCode);
    }
  }
  const valueString = values.join(',\n');
  const indentedValueString =
    generator.prefixLines(valueString, generator.INDENT);
  const codeString = '[\n' + indentedValueString + '\n]';
  return [codeString, Order.ATOMIC];
};

jsonGenerator.forBlock['object'] = function (block, generator) {
  const statementMembers =
    generator.statementToCode(block, 'MEMBERS');
  const code = '{\n' + statementMembers + '\n}';
  return [code, Order.ATOMIC];
};

//NGOQUOCVIET

//Thao tác di chuyển
jsonGenerator.forBlock['move_forward'] = function (block, generator) {
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const code = `sendData("W");\n` + `await delay(${value});\n` + `sendData("F");\n`;
  return code;
};

jsonGenerator.forBlock['move_backward'] = function (block, generator) {
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const code = `sendData("S");\n` + `await delay(${value});\n` + `sendData("F");\n`;
  return code;
};

jsonGenerator.forBlock['turn_left'] = function (block, generator) {
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const code = `sendData("A");\n` + `await delay(${value});\n` + `sendData("F");\n`;
  return code;
};

jsonGenerator.forBlock['turn_right'] = function (block, generator) {
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const code = `sendData("D");\n` + `await delay(${value});\n` + `sendData("F");\n`;
  return code;
};

//Thao tác di chuyển vĩnh cửu
jsonGenerator.forBlock['move_forward_infi'] = function (block, generator) {
  const code = `sendData("W");\n`;
  return code;
};

jsonGenerator.forBlock['move_backward_infi'] = function (block, generator) {
  const code = `sendData("S");\n`;
  return code;
};

jsonGenerator.forBlock['turn_left_infi'] = function (block, generator) {
  const code = `sendData("A");\n`;
  return code;
};

jsonGenerator.forBlock['turn_right_infi'] = function (block, generator) {
  const code = `sendData("D");\n`;
  return code;
};

//Dừng động cơ
jsonGenerator.forBlock['stopMovement'] = function (block, generated) {
  const code = `sendData('F')`
  return code;
}

//Thao tác linh kiện
// jsonGenerator.forBlock['turn_up'] = function (block, generator) {
//   const code = `Quay lên (value?);\n`;
//   return code;
// };

// jsonGenerator.forBlock['turn_down'] = function (block, generator) {
//   const code = `Quay xuống (value?);\n`;
//   return code;
// };

// jsonGenerator.forBlock['rotate'] = function (block, generator) {
//   const value = generator.valueToCode(
//     block, 'MEMBER_VALUE', Order.ATOMIC);
//   const code = `Quay (${value}) độ;\n`;
//   return code;
// };

//Giá trị
jsonGenerator.forBlock['second'] = function (block, generated) {
  const code = String(block.getFieldValue('NUM'));
  return [code, Order.ATOMIC];
}

//NGOVUVIETCODE
//new

jsonGenerator.forBlock['speak'] = function (block) {
  const textValue = jsonGenerator.valueToCode(block, 'TEXT_TO_SPEAK', Order.ATOMIC) || '""';
  const code = `speak(${textValue});\n`; // Replace with alert, speech synthesis, etc.
  return code;
};

jsonGenerator.forBlock['think'] = function (block) {
  const textValue = jsonGenerator.valueToCode(block, 'TEXT_TO_THINK', Order.ATOMIC) || '""';
  const code = `alert(${textValue});\n`; // Replace with other options if needed
  return code;
};

jsonGenerator.forBlock['repeat'] = function (block, generator) {
  const times = block.getFieldValue('MEMBER_VALUE');  // Get the number of repetitions from the block
  const value = generator.valueToCode(
    block, 'MEMBER_VALUE', Order.ATOMIC);
  const statementCode = generator.statementToCode(block, 'DO');  // Get the code to repeat

  // Create a for-loop that repeats the code 'times' number of times
  const code = `for (let i = 0; i < ${value}; i++) {\n${statementCode}\n}\n`;
  return code;
};
jsonGenerator.forBlock['forever'] = function (block, generator) {
  const statementCode = generator.statementToCode(block, 'DO');  // Get the code inside the block

  // Create a while loop that runs indefinitely
  const code = `while (true) {\n${statementCode}\n}\n`;
  return code;
};
jsonGenerator.forBlock['if'] = function (block, generator) {
  const condition = generator.valueToCode(block, 'CONDITION', Order.ATOMIC);  // Get the condition for the 'if' statement
  const statementCode = generator.statementToCode(block, 'DO');  // Get the actions to perform if the condition is true

  // Generate the if statement with the condition and actions inside
  const code = `if (${condition}) {\n${statementCode}\n}\n`;
  return code;
};
jsonGenerator.forBlock['if_else'] = function (block, generator) {
  const condition = generator.valueToCode(block, 'CONDITION', Order.ATOMIC);  // Get the condition for the 'if' statement
  const statementCode = generator.statementToCode(block, 'DO');  // Get the actions to perform if the condition is true
  const elseStatementCode = generator.statementToCode(block, 'DO_ELSE');  // Get the actions to perform if the condition is false

  // Generate the if-else statement with the condition and actions inside
  const code = `if (${condition}) {\n${statementCode}\n} else {\n${elseStatementCode}\n}\n`;
  return code;
};
jsonGenerator.forBlock['wait_until'] = function (block, generator) {
  const condition = generator.valueToCode(block, 'CONDITION', Order.ATOMIC);  // Get the condition for waiting

  // Generate the code to repeatedly check the condition
  const code = `while (!${condition}) {\n  // Đợi\n}\n`;
  return code;
};
jsonGenerator.forBlock['repeat_until'] = function (block, generator) {
  const condition = generator.valueToCode(block, 'CONDITION', Order.ATOMIC);  // Get the condition for the loop
  const statementCode = generator.statementToCode(block, 'DO');  // Get the actions to perform while looping

  // Generate the code to repeatedly check the condition and perform the action
  const code = `do {\n${statementCode}} while (!${condition});\n`;
  return code;
};
jsonGenerator.forBlock['stop'] = function (block) {
  // The code for stopping the program or exiting a loop is a break statement
  const code = 'break;\n';  // This is the JavaScript equivalent of stopping execution in a loop
  return code;
};

jsonGenerator.forBlock['key_pressed'] = function (block) {
  const key = block.getFieldValue('KEY');

  const code = `keypress_bd("${key}")\n`;
  return [code, Order.ATOMIC];
};

jsonGenerator.forBlock['ultrasonic_sensor_status'] = function (block) {
  // Replace `getUltrasonicSensor1Distance` with the actual function or API call
  // that retrieves the distance measurement from Ultrasonic Sensor 1.
  const code = 'getUltrasonicSensor1Distance()';
  return [code, Order.ATOMIC];
};
jsonGenerator.forBlock['ultrasonic_sensor2_status'] = function (block) {
  // Replace `getUltrasonicSensor2Distance` with the actual function that reads
  // the distance from Ultrasonic Sensor 2
  const code = 'getUltrasonicSensor2Distance()';
  return [code, Order.ATOMIC];
};
//ANH LUU VAR


//thiếu mathchange

// JSON-based generator for 'variables_set' block
jsonGenerator.forBlock['variables_set'] = function (block) {
  const variable = block.getFieldValue('VAR');  // Retrieve the user-defined variable name
  const value = jsonGenerator.valueToCode(block, 'VALUE', 0);  // Get the value connected to the 'VALUE' input
  return `${variable} = ${value};\n`;  // Assign without 'let'

};

// JSON-based generator for 'variables_get' block
jsonGenerator.forBlock['variables_get'] = function (block) {
  const variable = block.getFieldValue('VAR');  // Retrieve the user-defined variable name
  const code = `${variable}`;  // Return the variable name
  return [code, 0];  // Return the variable with atomic order (no extra operations)
};

//math_change
// JSON-based generator for 'variables_get' block
jsonGenerator.forBlock['math_change'] = function (block) {
    const variable = block.getFieldValue('VAR');  // Retrieve the user-defined variable name
    const value = jsonGenerator.valueToCode(block, 'VALUE', 0);  // Get the value connected to the 'VALUE' input
    return `${variable} = ${variable}+${value};\n`;  // Assign without 'let'
};

//KIEN SON START

jsonGenerator.forBlock['text_block'] = function (block) {
  const text = block.getFieldValue('TEXT');
  return `"${text}"`;
};

jsonGenerator.forBlock['number_block'] = function (block) {
  const number = block.getFieldValue('NUM');
  return [number !== null ? number.toString() : '0', Order.ATOMIC];
};

jsonGenerator.forBlock['math_add'] = function (block, generator) {
  const value1 = generator.valueToCode(block, 'NUM1', Order.ATOMIC) || '0';
  const value2 = generator.valueToCode(block, 'NUM2', Order.ATOMIC) || '0';
  return [`(${value1}) + (${value2})`, Order.ATOMIC];
};

jsonGenerator.forBlock['math_subtract'] = function (block, generator) {
  const value1 = generator.valueToCode(block, 'A', Order.ATOMIC) || '0';
  const value2 = generator.valueToCode(block, 'B', Order.ATOMIC) || '0';
  return [`(${value1}) - (${value2})`, Order.ATOMIC];
};

jsonGenerator.forBlock['math_multiply'] = function (block, generator) {
  const value1 = generator.valueToCode(block, 'A', Order.ATOMIC) || '0';
  const value2 = generator.valueToCode(block, 'B', Order.ATOMIC) || '0';
  return [`(${value1}) * (${value2})`, Order.ATOMIC];
};

jsonGenerator.forBlock['math_divide'] = function (block, generator) {
  const value1 = generator.valueToCode(block, 'A', Order.ATOMIC) || '0';
  const value2 = generator.valueToCode(block, 'B', Order.ATOMIC) || '1'; // tránh chia cho 0
  return [`(${value1}) / (${value2})`, Order.ATOMIC];
};

jsonGenerator.forBlock['math_random_int'] = function (block, generator) {
  const from = generator.valueToCode(block, 'FROM', Order.ATOMIC) || '0';
  const to = generator.valueToCode(block, 'TO', Order.ATOMIC) || '0';
  const result = `Math.floor(Math.random() * (${to} - ${from} + 1)) + ${from}`;
  return [result, Order.ATOMIC];
};

jsonGenerator.forBlock['math_modulo'] = function (block, generator) {
  const dividend = generator.valueToCode(block, 'DIVIDEND', Order.ATOMIC) || '0';
  const divisor = generator.valueToCode(block, 'DIVISOR', Order.ATOMIC) || '1'; // Tránh chia cho 0
  const result = `${dividend} % ${divisor}`;
  return [result, Order.ATOMIC];
};

jsonGenerator.forBlock['math_round'] = function (block, generator) {
  const num = generator.valueToCode(block, 'NUM', Order.ATOMIC) || '0';
  const result = `Math.round(${num})`;
  return [result, Order.ATOMIC];
};


jsonGenerator.forBlock['math_compare'] = function (block, generator) {
  const a = generator.valueToCode(block, 'A', Order.ATOMIC) || '0';
  const b = generator.valueToCode(block, 'B', Order.ATOMIC) || '0';
  const operator = block.getFieldValue('OP');
  let jsOperator = '==';

  switch (operator) {
    case 'EQ':
      jsOperator = '==';
      break;
    case 'GT':
      jsOperator = '>';
      break;
    case 'LT':
      jsOperator = '<';
      break;
    case 'GTE':
      jsOperator = '>=';
      break;
    case 'LTE':
      jsOperator = '<=';
      break;
    default:
      jsOperator = '==';
  }

  const result = `${a} ${jsOperator} ${b}`;
  return [result, Order.ATOMIC];
};


//END HERE


//End here

jsonGenerator.scrub_ = function (block, code, thisOnly) {
  const nextBlock =
    block.nextConnection && block.nextConnection.targetBlock();
  if (nextBlock && !thisOnly) {
    return code + '\n' + jsonGenerator.blockToCode(nextBlock);
  }
  return code;
};
